<!DOCTYPE html>
<html>
	<body>
		<input type='file' id='fileInput' />
		<div id='theta' />
		<canvas id='image' width=1280 height=720 />
		<script type='text/javascript'>
			const canvas = document.getElementById('image');
			const ctx = canvas.getContext('2d');

			const perspective = [
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, -.1, 1,
			];

			const lookat = (eye, center, up) => {
				const z = vectorUnit(vectorSub(eye, center));
				const x = vectorUnit(crossProduct(up, z));
				const y = vectorUnit(crossProduct(z, x));
				const minv = [ // what?
					x.x, x.y, x.z, 0,
					y.x, y.y, y.z, 0,
					z.x, z.y, z.z, 0,
					  0,   0,   0, 1,
				];
				const tr = [ // this is a translation, that makes sense
					1, 0, 0, -eye.x,
					0, 1, 0, -eye.y,
					0, 0, 1, -eye.z,
					0, 0, 0, 1,
				];
				return matrix4Mult4(minv, tr);
			};

			const keysdown = {};

			document.addEventListener('keydown', e => {
				if (e.repeat) {
					return;
				}

				keysdown[e.code] = true;
			});
			document.addEventListener('keyup', e => {
				keysdown[e.code] = false;
			});

			document.getElementById('fileInput').addEventListener('change', async e => {
				const filedata = await e.target.files[0].text();
				const model = parseWavefrontObject(filedata);

				console.log(`model has ${model.vertices.length} vertices, ${model.faces.length} faces`);

				const currentRotation = [
					Math.cos(0), 0, Math.sin(0),
					0, 1, 0,
					-Math.sin(0), 0, Math.cos(0),
				];

				let step = 0;
				let ztr = 0;
				const stepdiv = 64;

				const camera = vector(0, 0, 0);
				let lookTheta = 0;

				const pi2 = 2 * Math.PI;

				render(model, camera, lookTheta);
				setInterval(() => {
					if (keysdown.KeyW) {
						camera.z += (keysdown.ShiftLeft ? 0.3 : 0.1) * Math.cos(lookTheta);
					}
					if (keysdown.KeyS) {
						camera.z -= (keysdown.ShiftLeft ? 0.3 : 0.1) * Math.cos(lookTheta);
					}
					if (keysdown.KeyA) {
						camera.x += keysdown.ShiftLeft ? 0.3 : 0.1;
					}
					if (keysdown.KeyD) {
						camera.x -= keysdown.ShiftLeft ? 0.3 : 0.1;
					}
					if (keysdown.KeyQ) {
						lookTheta += keysdown.ShiftLeft ? 0.03 : 0.01;
						console.log(lookTheta, pi2, -pi2)
						if (lookTheta < -pi2 || lookTheta > pi2) {
							lookTheta = 0;
						}
					}
					if (keysdown.KeyE) {
						lookTheta -= keysdown.ShiftLeft ? 0.03 : 0.01;
						if (lookTheta < -pi2 || lookTheta > pi2) {
							lookTheta = 0;
						}
					}

////				document.getElementById('theta').innerHTML =
////					`theta: ${lookTheta * 180/Math.PI},
////					pos: x=${camera.x} y=${camera.y} z=${camera.z}`;

					const start = new Date();
					render(model, camera, lookTheta);
					const end = new Date();
					//console.log('elapsed', end - start);
				}, 1000/30);
			});

			const render = (model, cameraVector, lookTheta) => {
				const imageData = new ImageData(canvas.width, canvas.height);
				for (let i = 0; i < imageData.data.length; i += 4) {
					imageData.data[i+3] = 255;
				}
				for (let y = 90; y < imageData.width; y += 90) {
					line(imageData, 0, y, imageData.width-1, y, GREY);
				}
				for (let x = 160; x < imageData.width; x += 160) {
					line(imageData, x, 0, x, imageData.height-1, GREY);
				}

				const zbuf = [];
				for (let i = 0; i < imageData.width*imageData.height; ++i) {
					zbuf.push(-Infinity);
				}

				const lightSource = vector(0, 0, -1);

				const centerX = imageData.width / 2;
				const centerY = imageData.height / 2;

				const lookDirection = vector(
					cameraVector.x + Math.sin(lookTheta),
					cameraVector.y,
					cameraVector.z + Math.cos(lookTheta),
				);
				const cameraMatrix = lookat(cameraVector, lookDirection, vector(0,1,0));

				for (const face of model.faces) {
					let a = { ...model.vertices[face.vrefs[0]] };
					let b = { ...model.vertices[face.vrefs[1]] };
					let c = { ...model.vertices[face.vrefs[2]] };

					a = matrix4Project(cameraMatrix, a);
					b = matrix4Project(cameraMatrix, b);
					c = matrix4Project(cameraMatrix, c);

					a = matrix4Project(perspective, a);
					b = matrix4Project(perspective, b);
					c = matrix4Project(perspective, c);

					const screenA = point(Math.floor(centerX + a.x*centerY), Math.floor(centerY - a.y*centerY));
					const screenB = point(Math.floor(centerX + b.x*centerY), Math.floor(centerY - b.y*centerY));
					const screenC = point(Math.floor(centerX + c.x*centerY), Math.floor(centerY - c.y*centerY));
					if (!inBounds(imageData, screenA, 100) || !inBounds(imageData, screenB, 100) || !inBounds(imageData, screenC, 100)) {
						continue;
					}

					const f1 = vectorSub(c, a);
					const f2 = vectorSub(b, a);
					const fnorm = vectorUnit(crossProduct(f1, f2));
					const brightness = dotProduct(lightSource, fnorm);

					if (brightness > 0) {
						const rgb = Math.floor(brightness * 0xff);
						const color = [0, rgb, rgb, 0xff];
						triangle(zbuf, a.z, b.z, c.z, imageData, screenA, screenB, screenC, color);
					}
				}

				ctx.putImageData(imageData, 0, 0);
			};

			const inBounds = (imageData, point, buffer=0) =>
				point.x >= 0-buffer && point.y > 0-buffer &&
					point.x < imageData.width+buffer && point.y < imageData.height+buffer;

			const parseWavefrontObject = (contents) => {
				const model = { vertices: [], faces: [] };

				const lines = contents.split('\n');
				for (const line of lines) {
					if (line === '') { // blank
						continue;
					} else if (line.startsWith('#')) { // comment
						continue;
					} else if (line.startsWith('vt')) { // something texture
					} else if (line.startsWith('vn')) { // vertex normal?
					} else if (line.startsWith('g')) { // ???
					} else if (line.startsWith('s')) { // ???
					} else if (line.startsWith('v')) { // vertex
						const vdecl = line.split(' ');
						if (vdecl.length !== 4) {
							throw new Error('invalid v decl: ' + line);
						}

						const x = parseFloat(vdecl[1]);
						const y = parseFloat(vdecl[2]);
						const z = parseFloat(vdecl[3]);

						model.vertices.push(vector(x, y, z));
					} else if (line.startsWith('f')) { // face
						const fdecl = line.split(' ');
						if (fdecl.length !== 4) {
							throw new Error('invalid f decl: ' + line);
						}

						const f1 = fdecl[1].split('/');
						const f2 = fdecl[2].split('/');
						const f3 = fdecl[3].split('/');
						const vref1 = parseInt(f1[0]);
						const vref2 = parseInt(f2[0]);
						const vref3 = parseInt(f3[0]);

						model.faces.push({
							vrefs: [vref1-1, vref2-1, vref3-1],
						});
					} else {
						throw new Error('unrecognized line type: ' + line);
					}
				}

				return model;
			}


			const point = (x, y) => ({ x, y });
			const vector = (x, y, z) => ({ x, y, z });

			const vectorLength = ({ x, y, z }) =>
				Math.sqrt(x*x + y*y + z*z);

			const vectorUnit = (i) => {
				const len = vectorLength(i);
				return {
					x: i.x / len,
					y: i.y / len,
					z: i.z / len,
				};
			};

			const vectorSub = (i, j) =>
				vector(i.x - j.x, i.y - j.y, i.z - j.z);

			const dotProduct = (i, j) =>
				i.x*j.x + i.y*j.y + i.z*j.z;

			const crossProduct = (i, j) =>
				vector(i.y*j.z - i.z*j.y, i.z*j.x - i.x*j.z, i.x*j.y - i.y*j.x);

			const setPixel = (imageData, x, y, color) => {
				x = Math.floor(x);
				y = Math.floor(y);
				const p = (x + y*imageData.width) * 4;
				imageData.data[p] = color[0];
				imageData.data[p+1] = color[1];
				imageData.data[p+2] = color[2];
				imageData.data[p+3] = color[3];
			};

			const matrix3Mult = (m, v) => ({
				x: m[0]*v.x + m[1]*v.y + m[2]*v.z,
				y: m[3]*v.x + m[4]*v.y + m[5]*v.z,
				z: m[6]*v.x + m[7]*v.y + m[8]*v.z,
			});

			const matrix4Mult4 = (i, j) => [ // this is fine
				i[0]*j[0] +   i[1]*j[4] +  i[2]*j[8] +  i[3]*j[12] ,  i[0]*j[1] +  i[1]*j[5] +  i[2]*j[9] +  i[3]*j[13] ,  i[0]*j[2] +  i[1]*j[6] +  i[2]*j[10] +  i[3]*j[14] ,   i[0]*j[3] +  i[1]*j[7] +  i[2]*j[11] +  i[3]*j[15] ,
				i[4]*j[0] +   i[5]*j[4] +  i[6]*j[8] +  i[7]*j[12] ,  i[4]*j[1] +  i[5]*j[5] +  i[6]*j[9] +  i[7]*j[13] ,  i[4]*j[2] +  i[5]*j[6] +  i[6]*j[10] +  i[7]*j[14] ,   i[4]*j[3] +  i[5]*j[7] +  i[6]*j[11] +  i[7]*j[15] , 
				i[8]*j[0] +   i[9]*j[4] + i[10]*j[8] + i[11]*j[12] ,  i[8]*j[1] +  i[9]*j[5] + i[10]*j[9] + i[11]*j[13] ,  i[8]*j[2] +  i[9]*j[6] + i[10]*j[10] + i[11]*j[14] ,   i[8]*j[3] +  i[9]*j[7] + i[10]*j[11] + i[11]*j[15] , 
				i[12]*j[0] + i[13]*j[4] + i[14]*j[8] + i[15]*j[12] , i[12]*j[1] + i[13]*j[5] + i[14]*j[9] + i[15]*j[13] , i[12]*j[2] + i[13]*j[6] + i[14]*j[10] + i[15]*j[14] ,  i[12]*j[3] + i[13]*j[7] + i[14]*j[11] + i[15]*j[15] , 
			];

			const m4c = (r, c) => r*4 + c;

			const matrix4Project = (m, v) => {
				const x = m[0]*v.x + m[1]*v.y + m[2]*v.z + m[3];
				const y = m[4]*v.x + m[5]*v.y + m[6]*v.z + m[7];
				const z = m[8]*v.x + m[9]*v.y + m[10]*v.z + m[11];
				const zz = m[12]*v.x + m[13]*v.y + m[14]*v.z + m[15];
				return vector(x / zz, y / zz, z / zz);
			};

			const matrixViewport = (x, y, w, h, d) => [
				w/2,   0,   0, x+w/2,
				  0, h/2,   0, y+h/2,
				  0,   0, d/2,   d/2,
				  0,   0,   0,     1,
			];

			const line = (imageData, x0, y0, x1, y1, color) => {
				if (x1 < x0) {
					const tmpx = x0;
					const tmpy = y0;
					x0 = x1;
					x1 = tmp;
					y0 = y1;
					y1 = tmp;
				}

				const dy = y1 - y0;
				const dx = x1 - x0;
				if (dy < 0 && -dy > dx) {
					for (let i = 0; i <= -dy; ++i) {
						const sx = dx*i / -dy;
						setPixel(imageData, x0+sx, y0-i, color);
					}
				} else if (dx > dy) {
					for (let i = 0; i <= dx; ++i) {
						const sy = dy*i / dx;
						setPixel(imageData, x0+i, y0+sy, color);
					}
				} else {
					for (let i = 0; i <= dy; ++i) {
						const sx = dx*i / dy;
						setPixel(imageData, x0+sx, y0+i, color);
					}
				}
			};

			const barycentricCoordinates = (a, b, c, p) => {
				const v1 = vector(c.x - a.x, b.x - a.x, a.x - p.x);
				const v2 = vector(c.y - a.y, b.y - a.y, a.y - p.y);
				const cross = crossProduct(v1, v2);
				if (Math.abs(cross.z) < 1) {
					return { x: -1, y: -1, z: -1 };
				}

				return vector(
					1 - (cross.x+cross.y)/cross.z,
					cross.y / cross.z,
					cross.x / cross.z,
				);
			};

			const triangle = (zbuf, z1, z2, z3, imageData, a, b, c, color) => {
				const boxMin = point(Math.min(a.x, b.x, c.x), Math.min(a.y, b.y, c.y));
				const boxMax = point(Math.max(a.x, b.x, c.x), Math.max(a.y, b.y, c.y));

				for (let x = boxMin.x; x < boxMax.x; ++x) {
					for (let y = boxMin.y; y < boxMax.y; ++y) {
						const bc = barycentricCoordinates(a, b, c, point(x, y));
						if (bc.x < 0 || bc.y < 0 || bc.z < 0) {
							continue;
						}

						const z = bc.x*z1 + bc.y*z2 + bc.z*z3;
						const zi = x + y*imageData.height;

						if (zi >= 0 && zi < zbuf.length && zbuf[zi] < z) {
							setPixel(imageData, x, y, color);
							zbuf[zi] = z;
						}
					}
				}
			};

			const RED = [0xff,0,0,0xff];
			const GREY = [0x80,0x80,0x80,0xff];

			const imageData = new ImageData(canvas.width, canvas.height);
			for (let i = 0; i < imageData.data.length; i += 4) {
				imageData.data[i+3] = 255;
			}
			for (let y = 90; y < imageData.width; y += 90) {
				line(imageData, 0, y, imageData.width-1, y, GREY);
			}
			for (let x = 160; x < imageData.width; x += 160) {
				line(imageData, x, 0, x, imageData.height-1, GREY);
			}

			ctx.putImageData(imageData, 0, 0);
		</script>
	</body>
</html>
